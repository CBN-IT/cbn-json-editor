<link rel="import" href="../polymer/polymer.html">
<!--<script src="../webcomponentsjs/webcomponents.js"></script>-->
<link rel="import" href="../core-icon/core-icon.html">
<link rel="import" href="../core-icon-button/core-icon-button.html">
<link href="../paper-dialog/paper-dialog.html" rel="import">
<link href="../paper-dialog/paper-action-dialog.html" rel="import">

<!-- <link rel="import" href="../../polymer-gestures.html"> -->
<polymer-element name="cbn-json-editor-group" attributes="label list collapse id dialog">
  <template>
    <link rel="stylesheet" type="text/css" href="cbn-json-editor-group.css">
    <ul id="ulist" class="font-special list" touch-action="pan-y" size="3">
      <template repeat="{{item, i in list}}">
        <li value="{{idAdapter(i)}}_spacer" class="spacer beSmall"></li>
        <!--important:type-item-->
        <li value="{{idAdapter(i)}}"  class="item" type="item" style="padding-left:10px;line-height: 46px;list-style-type: none;font-family: 'Roboto', sans-serif;border-bottom: 1px solid #e0e0e0;cursor: move;background-color: white;color: black;">
          <span class="head-element">{{item.label}}</span>
          <span class="info-element">{{item.type}}</span>
          <span class="required-element">
            <template if="{{item.validation.required}}">
              Obligatoriu
            </template>
          </span>
          <core-icon-button  value="{{idAdapter(i)}}" icon="delete" class="trash-element" title="delete" on-click="{{delete}}"></core-icon-button>
        </li>
      </template>
      <li value="last_spacer" id="spacer" class="spacer beSmall"></li>

    </ul>


  </template>
  <script type="text/javascript" src="utils.js"></script>
  <script>

    /* global PolymerGestures */
    'use strict';

    (function() {
      var noop = function() {

      };
      Polymer('cbn-json-editor-group', { /* jshint ignore:line  */
        type: 'type',

        list: [],
        title:'',
        collapse:"",
        form:"",
        editTitle:function() {
          //this.toogleDoalo
          this.collapse=!this.collapse;
        },
        collapseGo:function() {
          this.collapse=!this.collapse;
        },
        collapseChanged:function() {
          this.$.ulist.hidden=!this.collapse;
        },
        toggleDialog2:function(sourceItem,index) {
//          sourceItem.id=index;//aici
          this.dialog.content=JSON.parse(JSON.stringify(sourceItem));
          this.dialog.initial=sourceItem;
          this.dialog.item=this;
          this.dialog.index=index;
          this.dialog.parentNode.toggle();
        },
        delete: function(event, detail, sender) {
          var index=sender.getAttribute("value");
          this.list.splice(index, 1);
          this.fire('update-json',{});
        },
        listChanged:function(){
          if(this.list.length==0 && this.initiateBig.contains('beSmall')){
            this.$.spacer.classList.remove('beSmall');
            this.$.spacer.classList.add('beBig');
          }
        },
        attached: function() {
          // populate the elementâ€™s data model
          // (the salutations array)
          this.title = this.title || 'Group';
          this.list = this.list || [];
          this.initiateBig=this.$.spacer.classList;
          this.collapse=this.collapse || false;
          this.$.ulist.hidden=!this.collapse;
//          console.log(this.form);
          var parent = this.parentElement;
          var self = this;
          parent.oncontextmenu = function() {
            return false;
          };
          PolymerGestures.addEventListener(this.$.ulist, 'trackstart', function(e) {
            var li = e.path[0];
            if(li.nodeName == 'SPAN'){
              self.initiateItemDrag(li.parentNode, e);
            }
            else if(li.nodeName == 'LI'){
              self.initiateItemDrag(li, e);
            }
            else {
              return;
            }
          });
          PolymerGestures.addEventListener(this.$.ulist, 'tap', function(e) {
            var li = e.path[0];
            if(li.nodeName == 'SPAN'){
              self.toggleDialog2(self.list[li.parentNode.getAttribute("value")],li.parentNode.getAttribute("value"));

            }
            else if(li.nodeName == 'LI'){
              self.toggleDialog2(self.list[li.getAttribute("value")],li.parentNode.getAttribute("value"));

            }
            else {
              return;
            }
//            self.toggleDialog2(self.list[li.parentNode.getAttribute("value")],li.parentNode.getAttribute("value"));
          });
        },
        getRowHeights: function() {
          var bounds = this.$.ulist.getBoundingClientRect();
          var items = this.$.ulist.querySelectorAll('li.item').array();
          if (items.length === 0) {
            return [0];
          }
          var boundries = items.map(function(e) {
            return e.getBoundingClientRect().top - bounds.top;
          });
          var last = items[items.length - 1];
          boundries.push(boundries[boundries.length - 1] + last.getBoundingClientRect().height);
          boundries[0] = 0;
          return boundries;
        },
        //these cand be overriden, or the label and id values can be override
        labelAdapter: function(item) {

          if (typeof item === 'object') {
            return item[this.type];
          }
          return item;
        },
        idAdapter: function(item) {
          if (typeof item === 'object') {
            return item[this.id];
          }
          return item;
        },
        //I've just been dragged over, this is the notification
        handleDragHoverEnter: function(dragged, x, y) {
          noop(dragged, x, y);
        },
        //I've just had a dragging operation leave me and
        //begin hovering over another drag target
        handleDragHoverExit: function(dragged, x, y) {
          noop(dragged, x, y);
          this.correctItemState();
        },
        //I'm being dragged over
        handleDragOver: function(dragged, x, y) {
          var self = this;
          var bounds = this.$.ulist.getBoundingClientRect();
          var boundries = this.getRowHeights();
          var localY = y - bounds.top;
          var minValue = 1000000;
          var minIndex = 0;
          for (var i = 0; i < boundries.length; i++) {
            var distance = Math.abs(localY - boundries[i]);
            if (distance < minValue) {
              minIndex = i;
              minValue = distance;
            }
          }
          var overRow = minIndex;
          if (this.overRow !== overRow) {
            if (this.isTransition) {
              return;
            }
            this.isTransition = true;
            var spacers = this.$.ulist.querySelectorAll('li.spacer');
            //shrink previous if it exists
            if (this.overRow || this.overRow === 0) {
              var previous = this.$.ulist.querySelector('li.spacer.beBig');
              if (previous) {
                previous.classList.add('transition');
                requestAnimationFrame(function() {
                  previous.classList.remove('beBig');
                  previous.classList.add('beSmall');
                });
              }
            }
            //expand current
            this.overRow = overRow;
            var spacer = spacers[overRow];
            spacer.classList.add('transition');
            requestAnimationFrame(function() {
              spacer.classList.remove('beSmall');
              spacer.classList.add('beBig');
              setTimeout(function() {
                spacer.classList.remove('transition');
                self.isTransition = false;
              }, 210);
            });
          }
        },
        handleDrag: function(e) {
          if (!this.dragFodder) {
            return;
          }
          var dragFodderRect = this.dragFodder.getBoundingClientRect();
          var cxo = dragFodderRect.width / 2;
          var cyo = dragFodderRect.height / 2;

          var globalX = this.dragEventStart[0];
          var globalY = (e.y || e.clientY) - this.dragEventStart[1];
          //var sx = this.dragItemStart[0];
          //var sy = this.dragItemStart[1];
          this.setCssLocation(this.dragFodder.style, globalX, globalY);
          //lets check for a drag over....
          //we need to make invisible briefly so as not to
          //obscure what it's over
          this.dragFodder.style.display = 'none';
          var dropTarget = document.elementFromPoint(globalX + cxo, globalY + cyo);

          while (dropTarget != null && dropTarget.tagName!="CBN-JSON-EDITOR-FORM") {
            if (dropTarget.shadowRoot != null) {
              dropTarget = dropTarget.shadowRoot.elementFromPoint(globalX + cxo, globalY + cyo)
            } else {
              dropTarget = null;
            }
          }

          if(
            dropTarget.shadowRoot.elementFromPoint(globalX + cxo, globalY + cyo).tagName=="DIV")
          {
            var index = dropTarget.shadowRoot.elementFromPoint(globalX + cxo, globalY + cyo).getAttribute('value');
            if(dropTarget.list[index]&& dropTarget.list[index].collapsed==false &&
              dropTarget.timeout=='' && this.indexGroup==index) {
              this.fire('set-timeout',{index:index});
            }
            else if(dropTarget.list[index] && dropTarget.list[index].collapsed==false && this.indexGroup!=index) {
              this.fire('set-timeout',{index:index});
            }
          }

          if(
            dropTarget.shadowRoot.elementFromPoint(globalX + cxo, globalY + cyo).tagName.toUpperCase()=="CBN-JSON-EDITOR-GROUP"){
            dropTarget = dropTarget.shadowRoot.elementFromPoint(globalX + cxo, globalY + cyo);

          }
          this.dragFodder.style.display = '';

          if (dropTarget && dropTarget.handleDragOver) {
            if (this.currentDropTarget !== dropTarget) {
              if (!dropTarget.canDropItem(this.list, dropTarget.list, this.dragFodder.sourceIndex, this.dragFodder.dragItem, e)) {
                return;
              }
              if (this.currentDropTarget) {
                this.currentDropTarget.handleDragHoverExit(this.dragFodder, globalX + cxo, globalY + cyo);
              }
              this.currentDropTarget = dropTarget;
              this.currentDropTarget.handleDragHoverEnter(this.dragFodder, globalX + cxo, globalY + cyo);
            }
            dropTarget.handleDragOver(this.dragFodder, globalX + cxo, globalY + cyo);
          }
        },
        //lets notify the drop target of a drop
        //the dropItem contains it's source, dragSource
        handleDrop: function(e) {
          noop(e);
          var dropTarget = this.currentDropTarget;
          var dragFodder = this.dragFodder;
          dropTarget.listItemDropped(dragFodder);
        },
        //ive had a list item dropped on me do the proper thing
        listItemDropped: function(listItem) {
          var self = this;
          var dropSpacer = this.$.ulist.querySelector('li.spacer.beBig');
          var items = this.$.ulist.querySelectorAll('li').array();
          var sourceItem = listItem.dragItem;
          var insertIndex = items.indexOf(dropSpacer) / 2;
          var targetRect = dropSpacer.getBoundingClientRect();
          var targetTop = targetRect.top;
          var targetLeft = targetRect.left;
          listItem.style.webkitTransition = '-webkit-transform 150ms ease-in';
          listItem.style.MozTransition = '-moz-transform 150ms ease-in';
          listItem.style.msTransition = '-ms-transform 150ms ease-in';
          listItem.style.oTransition = '-o-transform 150ms ease-in';
          listItem.style.transition = 'transform 150ms ease-in';
          var that=this;
          requestAnimationFrame(function() {
            self.setCssLocation(listItem.style, targetLeft, targetTop);
            setTimeout(function() {
              listItem.parentElement.removeChild(listItem);

              dropSpacer.classList.remove('beBig');
              dropSpacer.classList.add('beSmall');
              self.list.splice(insertIndex, 0, JSON.parse(JSON.stringify(sourceItem)));
//              that.fire('update-json',{});
              if(sourceItem.name==""){
                self.toggleDialog2(self.list[insertIndex],insertIndex);
              }else{
                that.fire('update-json',{});
              }
              self.overRow = undefined;
            }, 170);
          });
        },
        //this function can be replaced to
        //control what can be dragged out and what cannot
        canDragItem: function(list, item, index, e) {
          noop(list, item, index, e);

          //some examples....
          //return list.length > 1; // 1 item must be left
          //return item !== 'sector'; // can't remove sector
          //default allow anything to be dragged out
          return true;
        },
        //this function can be replaced to
        //control what can be dragged out and what cannot
        //the api could be done better given more time,
        //but this will suffice for current needs
        canDropItem: function(sourceList, myList, sourceIndex, item, e) {
          noop(sourceList, myList, sourceIndex, item, e);
          //this.collapseGoOver();


          //some examples....
          //return ['sector', 'gics', 'strategy'].indexOf(item) > -1; // 1 item must be in this list
          //return item !== 'sector'; // can't drop sector here
          //default allow anything to be dragged out
//          console.log(this.collapse);

          return this.collapse;



        },
        initiateItemDrag: function(li, e) {
          //let' attach the this as the drag source to
          //the item were dragging around
          li.dragSource = this;
          li.dragIndex = parseInt(li.getAttribute('value'));
          li.dragItem = this.list[li.dragIndex];
          if (!this.canDragItem(this.list, li.dragItem, li.dragIndex, e)) {
            return;
          }
          this.overRow = undefined;
          var transitions = this.$.ulist.querySelectorAll('.transition').array();
          transitions.forEach(function(e) {
            e.classList.remove('transition');
          });
          e.preventDefault();
          var goAwayer = li.nextElementSibling;
          var bounds = li.getBoundingClientRect();
          var self = this;
          var parent = this.$.ulist;
          var parentBounds = parent.getBoundingClientRect();
          //li.classList.add('level3');
          li.style.width = parentBounds.width + 'px';
          this.list.splice(li.dragIndex, 1);
          this.dragFodder = li;

          this.dragEventStart = [bounds.left, (e.y || e.clientY) - bounds.top];
          //lets insert this guy and do a transition to
          //shrink his height
          //goAwayer.classList.remove('transition');
          goAwayer.classList.add('beBig');
          goAwayer.classList.remove('beSmall');
//          console.dir(li);
          document.body.appendChild(li);
          PolymerGestures.addEventListener(li, 'track', function(e) {
            self.handleDrag(e);
          });
          var that=this;
          PolymerGestures.addEventListener(li, 'trackend', function(e) {
            self.handleDrop(e);
          });
          // PolymerGestures.addEventListener(li, 'up', function(e) {
          //     console.log('up', e);
          // });
          requestAnimationFrame(function() {
            //goAwayer.classList.remove('beBig');
            //goAwayer.classList.add('beSmall');
            //goAwayer.classList.add('transition');
            //wait a little longer than the transition
            //and remove the spacer so as not to have
            //duplicate spacers
            setTimeout(function() {
              goAwayer.classList.remove('transition');
            }, 210);
          });
          //make the new guy generate touch events
        },
        setCssLocation: function(style, x, y) {
          style.position = 'fixed';
          style.zIndex = 10;
          style.top = 0;
          style.left = 0;
          style.webkitTransform = 'translate(' + x + 'px, ' + y + 'px)';
          style.MozTransform = 'translate(' + x + 'px, ' + y + 'px)';
          style.mmsTransform = 'translate(' + x + 'px, ' + y + 'px)';
          style.oTransform = 'translate(' + x + 'px, ' + y + 'px)';
          style.transform = 'translate(' + x + 'px, ' + y + 'px)';
          style.border = '1px solid #bbbbbb';
          style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        },
        //I no longer have a drop prospect, it has hovered over another drop prospect, correct my expansion state
        correctItemState: function() {
          var self = this;
          var spacer = this.$.ulist.querySelector('li.spacer.beBig');
          if (spacer) {
            var that=this;
            requestAnimationFrame(function() {
              if(that.list.length!=0){
                spacer.classList.remove('beBig');
                spacer.classList.add('beSmall');
                spacer.classList.add('transition');
                //wait a little longer than the transition
                //and remove the spacer so as not to have
                //duplicate spacers
                setTimeout(function() {
                  spacer.classList.remove('transition');
                  self.overRow = undefined;
                }, 210);
              }

            });
          }
        }
      });
    })();
  </script>
</polymer-element>
